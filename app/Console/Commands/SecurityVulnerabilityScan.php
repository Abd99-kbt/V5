<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

class SecurityVulnerabilityScan extends Command
{
    protected $signature = 'security:scan 
                          {--type=full : Scan type (full, quick, dependency, code)}
                          {--output=console : Output format (console, json, html)}
                          {--severity=medium : Minimum severity level (low, medium, high, critical)}
                          {--save-results : Save results to database}
                          {--notify : Send notifications for critical findings}';

    protected $description = 'Perform comprehensive security vulnerability scanning';

    private $vulnerabilities = [];
    private $scanResults = [];
    private $severityLevels = ['low' => 1, 'medium' => 2, 'high' => 3, 'critical' => 4];
    private $minSeverity;

    public function handle()
    {
        $this->info('ðŸ”’ Starting Security Vulnerability Scan...');
        $this->info('Time: ' . now()->toISOString());
        
        $this->minSeverity = $this->severityLevels[$this->option('severity')] ?? 2;
        
        try {
            switch ($this->option('type')) {
                case 'quick':
                    $this->quickScan();
                    break;
                case 'dependency':
                    $this->dependencyScan();
                    break;
                case 'code':
                    $this->codeScan();
                    break;
                case 'full':
                default:
                    $this->fullScan();
                    break;
            }
            
            $this->displayResults();
            $this->saveResults();
            $this->sendNotifications();
            
            $this->info('âœ… Security scan completed successfully!');
            
            return 0;
            
        } catch (\Exception $e) {
            $this->error('âŒ Security scan failed: ' . $e->getMessage());
            Log::channel('security')->error('Security scan failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            return 1;
        }
    }

    private function quickScan(): void
    {
        $this->info('ðŸ” Performing quick security scan...');
        
        // Critical checks only
        $this->checkEnvironmentConfiguration();
        $this->checkBasicSecurityHeaders();
        $this->checkDependencyVulnerabilities();
        $this->checkKnownVulnerabilities();
    }

    private function fullScan(): void
    {
        $this->info('ðŸ” Performing comprehensive security scan...');
        
        // Environment and configuration
        $this->checkEnvironmentConfiguration();
        $this->checkDatabaseSecurity();
        $this->checkCacheSecurity();
        $this->checkSessionSecurity();
        $this->checkCSRFConfiguration();
        
        // Application security
        $this->checkBasicSecurityHeaders();
        $this->checkContentSecurityPolicy();
        $this->checkInputValidation();
        $this->checkOutputEncoding();
        $this->checkFileUploadSecurity();
        
        // Code analysis
        $this->codeScan();
        
        // Dependency scanning
        $this->dependencyScan();
        
        // External vulnerability database
        $this->checkKnownVulnerabilities();
        
        // Performance and resource checks
        $this->checkPerformanceSecurity();
    }

    private function dependencyScan(): void
    {
        $this->info('ðŸ“¦ Scanning dependencies for vulnerabilities...');
        
        // Check composer dependencies
        $this->scanComposerDependencies();
        
        // Check npm dependencies if applicable
        if (File::exists(base_path('package.json'))) {
            $this->scanNpmDependencies();
        }
        
        // Check for abandoned packages
        $this->checkAbandonedPackages();
    }

    private function codeScan(): void
    {
        $this->info('ðŸ”Ž Scanning code for security issues...');
        
        $this->scanForSQLInjection();
        $this->scanForXSS();
        $this->scanForCommandInjection();
        $this->scanForPathTraversal();
        $this->scanForInsecureFileOperations();
        $this->scanForHardcodedSecrets();
        $this->scanForInsecureRandom();
        $this->scanForInsecureFunctions();
    }

    private function checkEnvironmentConfiguration(): void
    {
        $this->info('ðŸŒ Checking environment configuration...');
        
        // Check if debug mode is disabled in production
        if (app()->environment('production') && config('app.debug')) {
            $this->addVulnerability([
                'type' => 'debug_mode',
                'severity' => 'high',
                'title' => 'Debug Mode Enabled in Production',
                'description' => 'Debug mode should be disabled in production environments',
                'recommendation' => 'Set APP_DEBUG=false in production environment',
                'file' => '.env',
                'line' => 'N/A'
            ]);
        }
        
        // Check secure session configuration
        if (!config('session.secure') && app()->environment('production')) {
            $this->addVulnerability([
                'type' => 'insecure_session',
                'severity' => 'high',
                'title' => 'Insecure Session Configuration',
                'description' => 'Sessions should be configured with secure settings in production',
                'recommendation' => 'Set SESSION_SECURE=true and SESSION_HTTP_ONLY=true',
                'file' => 'config/session.php',
                'line' => 'N/A'
            ]);
        }
        
        // Check HTTPS enforcement
        if (!config('app.force_https') && app()->environment('production')) {
            $this->addVulnerability([
                'type' => 'no_https_enforcement',
                'severity' => 'medium',
                'title' => 'HTTPS Not Enforced',
                'description' => 'HTTPS should be enforced in production environments',
                'recommendation' => 'Set APP_FORCE_HTTPS=true and configure web server for HTTPS',
                'file' => '.env',
                'line' => 'N/A'
            ]);
        }
        
        // Check for weak encryption
        $bcryptRounds = env('BCRYPT_ROUNDS', 10);
        if ($bcryptRounds < 12) {
            $this->addVulnerability([
                'type' => 'weak_encryption',
                'severity' => 'medium',
                'title' => 'Weak Password Hashing',
                'description' => 'BCrypt rounds should be at least 12 for production',
                'recommendation' => "Set BCRYPT_ROUNDS=12 or higher in environment",
                'file' => '.env',
                'line' => 'N/A'
            ]);
        }
    }

    private function checkDatabaseSecurity(): void
    {
        $this->info('ðŸ—„ï¸ Checking database security...');
        
        // Check database connection security
        if (!config('database.connections.mysql.sslmode')) {
            $this->addVulnerability([
                'type' => 'database_ssl',
                'severity' => 'medium',
                'title' => 'Database SSL Not Configured',
                'description' => 'Database connections should use SSL encryption',
                'recommendation' => 'Configure SSL mode for database connections',
                'file' => 'config/database.php',
                'line' => 'N/A'
            ]);
        }
        
        // Check for debug logging in production
        if (app()->environment('production') && config('database.log_queries', false)) {
            $this->addVulnerability([
                'type' => 'query_logging_production',
                'severity' => 'medium',
                'title' => 'Query Logging Enabled in Production',
                'description' => 'Query logging in production can expose sensitive data',
                'recommendation' => 'Disable query logging in production environment',
                'file' => 'config/database.php',
                'line' => 'N/A'
            ]);
        }
    }

    private function checkBasicSecurityHeaders(): void
    {
        $this->info('ðŸ›¡ï¸ Checking security headers...');
        
        $testUrl = config('app.url') . '/';
        
        try {
            $response = Http::timeout(10)->get($testUrl);
            
            $headers = $response->headers();
            $requiredHeaders = [
                'X-Content-Type-Options' => 'nosniff',
                'X-Frame-Options' => ['DENY', 'SAMEORIGIN'],
                'X-XSS-Protection' => ['1; mode=block', '0'],
            ];
            
            foreach ($requiredHeaders as $header => $expectedValues) {
                if (!isset($headers[strtolower($header)])) {
                    $this->addVulnerability([
                        'type' => 'missing_security_header',
                        'severity' => 'medium',
                        'title' => "Missing Security Header: {$header}",
                        'description' => "Security header {$header} is missing from responses",
                        'recommendation' => "Add {$header} header via middleware",
                        'file' => 'app/Http/Middleware/SecurityHeaders.php',
                        'line' => 'N/A'
                    ]);
                }
            }
            
        } catch (\Exception $e) {
            $this->error("Could not check headers for {$testUrl}: " . $e->getMessage());
        }
    }

    private function checkContentSecurityPolicy(): void
    {
        $this->info('ðŸ“‹ Checking Content Security Policy...');
        
        $testUrl = config('app.url') . '/';
        
        try {
            $response = Http::timeout(10)->get($testUrl);
            $headers = $response->headers();
            $csp = isset($headers['content-security-policy']) ? $headers['content-security-policy'][0] : null;
            
            if (!$csp) {
                $this->addVulnerability([
                    'type' => 'missing_csp',
                    'severity' => 'high',
                    'title' => 'Missing Content Security Policy',
                    'description' => 'Content Security Policy header is missing',
                    'recommendation' => 'Implement CSP header to prevent XSS attacks',
                    'file' => 'app/Http/Middleware/SecurityHeaders.php',
                    'line' => 'N/A'
                ]);
            } else {
                // Check CSP configuration
                $cspIssues = $this->analyzeCSP($csp);
                foreach ($cspIssues as $issue) {
                    $this->addVulnerability($issue);
                }
            }
            
        } catch (\Exception $e) {
            $this->error("Could not check CSP for {$testUrl}: " . $e->getMessage());
        }
    }

    private function analyzeCSP(string $csp): array
    {
        $issues = [];
        
        // Check for unsafe-inline
        if (strpos($csp, "'unsafe-inline'") !== false) {
            $issues[] = [
                'type' => 'csp_unsafe_inline',
                'severity' => 'medium',
                'title' => 'CSP Allows Inline Scripts',
                'description' => 'CSP should avoid allowing unsafe-inline for better security',
                'recommendation' => 'Use nonces or hashes instead of unsafe-inline',
                'file' => 'app/Http/Middleware/SecurityHeaders.php',
                'line' => 'N/A'
            ];
        }
        
        // Check for wildcard sources
        if (strpos($csp, '*') !== false) {
            $issues[] = [
                'type' => 'csp_wildcard',
                'severity' => 'medium',
                'title' => 'CSP Uses Wildcard Sources',
                'description' => 'CSP should use specific sources rather than wildcards',
                'recommendation' => 'Replace wildcard sources with specific domains',
                'file' => 'app/Http/Middleware/SecurityHeaders.php',
                'line' => 'N/A'
            ];
        }
        
        return $issues;
    }

    private function checkInputValidation(): void
    {
        $this->info('ðŸ“ Checking input validation...');
        
        // This would involve analyzing validation rules
        // For now, we'll check if validation middleware is registered
        
        $middlewareConfig = config('app.security_middleware_enabled', false);
        
        if (!$middlewareConfig) {
            $this->addVulnerability([
                'type' => 'missing_input_validation',
                'severity' => 'high',
                'title' => 'Input Validation Not Enabled',
                'description' => 'Security middleware for input validation is not enabled',
                'recommendation' => 'Enable and configure input validation middleware',
                'file' => 'app/Http/Kernel.php',
                'line' => 'N/A'
            ]);
        }
    }

    private function scanComposerDependencies(): void
    {
        $this->info('ðŸ“¦ Scanning Composer dependencies...');
        
        try {
            // Run composer audit
            exec('composer audit --format=json 2>/dev/null', $output, $returnCode);
            
            if ($returnCode === 0 && !empty($output)) {
                $auditResult = json_decode(implode("\n", $output), true);
                
                if (isset($auditResult['vulnerabilities'])) {
                    foreach ($auditResult['vulnerabilities'] as $vuln) {
                        $this->addVulnerability([
                            'type' => 'dependency_vulnerability',
                            'severity' => $this->mapSeverity($vuln['severity'] ?? 'medium'),
                            'title' => "Vulnerable Dependency: {$vuln['package']}",
                            'description' => $vuln['title'] ?? 'Security vulnerability detected',
                            'recommendation' => "Update {$vuln['package']} to a secure version",
                            'file' => 'composer.json',
                            'line' => 'N/A',
                            'extra_data' => $vuln
                        ]);
                    }
                }
            }
            
        } catch (\Exception $e) {
            $this->warn("Could not scan Composer dependencies: " . $e->getMessage());
        }
    }

    private function scanForSQLInjection(): void
    {
        $this->info('ðŸ” Scanning for potential SQL injection vulnerabilities...');
        
        $files = $this->getPhpFiles(['app', 'routes']);
        $sqlPatterns = [
            '/DB::\w+\(\s*["\'][^"\']*\s*\.\s*.*?["\'].*?\)/i',
            '/\$pdo->\w+\(\s*["\'][^"\']*\s*\.\s*.*?["\'].*?\)/i',
            '/mysqli_query\(\s*[^,]+,\s*["\'][^"\']*\s*\.\s*.*?["\'].*?\)/i'
        ];
        
        foreach ($files as $file) {
            $content = File::get($file);
            foreach ($sqlPatterns as $pattern) {
                if (preg_match_all($pattern, $content, $matches)) {
                    $lines = explode("\n", $content);
                    foreach ($matches[0] as $match) {
                        $lineNum = $this->findLineNumber($lines, $match);
                        $this->addVulnerability([
                            'type' => 'potential_sql_injection',
                            'severity' => 'high',
                            'title' => 'Potential SQL Injection',
                            'description' => 'Possible SQL injection vulnerability detected',
                            'recommendation' => 'Use parameter binding or ORM methods',
                            'file' => $file,
                            'line' => $lineNum,
                            'code' => trim($match)
                        ]);
                    }
                }
            }
        }
    }

    private function scanForXSS(): void
    {
        $this->info('ðŸ” Scanning for potential XSS vulnerabilities...');
        
        $files = $this->getPhpFiles(['app', 'resources/views']);
        $xssPatterns = [
            '/echo\s+\$[^;]+;/i',
            '/print\s+\$[^;]+;/i',
            '/\{\!\![^}]*\}/', // Blade unescaped output
            '/@?\{{[^}]*\}/'   // Blade output
        ];
        
        foreach ($files as $file) {
            $content = File::get($file);
            foreach ($xssPatterns as $pattern) {
                if (preg_match_all($pattern, $content, $matches)) {
                    $lines = explode("\n", $content);
                    foreach ($matches[0] as $match) {
                        $lineNum = $this->findLineNumber($lines, $match);
                        
                        // Check if output is escaped
                        $needsEscaping = true;
                        if (strpos($file, '.blade.php') !== false) {
                            if (strpos($match, '{!!') !== false) {
                                $needsEscaping = false;
                            } elseif (strpos($match, '{{') !== false) {
                                $needsEscaping = false;
                            }
                        }
                        
                        if ($needsEscaping) {
                            $this->addVulnerability([
                                'type' => 'potential_xss',
                                'severity' => 'medium',
                                'title' => 'Potential XSS Vulnerability',
                                'description' => 'Unescaped output detected',
                                'recommendation' => 'Escape user input before outputting',
                                'file' => $file,
                                'line' => $lineNum,
                                'code' => trim($match)
                            ]);
                        }
                    }
                }
            }
        }
    }

    private function scanForHardcodedSecrets(): void
    {
        $this->info('ðŸ” Scanning for hardcoded secrets...');
        
        $files = $this->getPhpFiles(['app', 'config', 'routes']);
        $secretPatterns = [
            '/password\s*=\s*["\'][^"\']{8,}["\']/i',
            '/api_key\s*=\s*["\'][^"\']{16,}["\']/i',
            '/secret\s*=\s*["\'][^"\']{16,}["\']/i',
            '/token\s*=\s*["\'][^"\']{16,}["\']/i',
            '/private_key\s*=\s*["\'][^"\']{50,}["\']/i',
        ];
        
        foreach ($files as $file) {
            $content = File::get($file);
            foreach ($secretPatterns as $pattern) {
                if (preg_match_all($pattern, $content, $matches)) {
                    $lines = explode("\n", $content);
                    foreach ($matches[0] as $match) {
                        $lineNum = $this->findLineNumber($lines, $match);
                        $this->addVulnerability([
                            'type' => 'hardcoded_secret',
                            'severity' => 'high',
                            'title' => 'Hardcoded Secret Detected',
                            'description' => 'Potential hardcoded secret found in source code',
                            'recommendation' => 'Move secrets to environment variables',
                            'file' => $file,
                            'line' => $lineNum,
                            'code' => '***SECRET***'
                        ]);
                    }
                }
            }
        }
    }

    private function checkKnownVulnerabilities(): void
    {
        $this->info('ðŸŒ Checking against known vulnerability databases...');
        
        // This would integrate with CVE databases or vulnerability feeds
        // For now, we'll simulate basic checks
        
        $laravelVersion = app()->version();
        $this->checkLaravelVersion($laravelVersion);
        
        $phpVersion = PHP_VERSION;
        $this->checkPhpVersion($phpVersion);
    }

    private function checkLaravelVersion(string $version): void
    {
        // Known vulnerable Laravel versions
        $vulnerableVersions = [
            '5.5.0' => 'Remote Code Execution in Taylor Otwell',
            '5.6.0' => 'XSS in Mail Template',
            '7.0.0' => 'SQL Injection in Eloquent',
        ];
        
        foreach ($vulnerableVersions as $vulnVersion => $description) {
            if (version_compare($version, $vulnVersion, '=')) {
                $this->addVulnerability([
                    'type' => 'vulnerable_laravel_version',
                    'severity' => 'critical',
                    'title' => "Vulnerable Laravel Version: {$version}",
                    'description' => $description,
                    'recommendation' => 'Update Laravel to the latest stable version',
                    'file' => 'composer.json',
                    'line' => 'N/A'
                ]);
            }
        }
    }

    private function checkPhpVersion(string $version): void
    {
        $unsupportedVersions = ['5.6', '7.0', '7.1', '7.2', '7.3'];
        
        foreach ($unsupportedVersions as $unsupported) {
            if (strpos($version, $unsupported) === 0) {
                $this->addVulnerability([
                    'type' => 'unsupported_php_version',
                    'severity' => 'high',
                    'title' => "Unsupported PHP Version: {$version}",
                    'description' => 'This PHP version is no longer supported and may have security vulnerabilities',
                    'recommendation' => 'Upgrade to a supported PHP version (8.0 or higher)',
                    'file' => 'composer.json',
                    'line' => 'N/A'
                ]);
            }
        }
    }

    private function getPhpFiles(array $directories): array
    {
        $files = [];
        
        foreach ($directories as $directory) {
            $path = base_path($directory);
            if (File::exists($path)) {
                $directoryFiles = File::allFiles($path);
                foreach ($directoryFiles as $file) {
                    if ($file->getExtension() === 'php') {
                        $files[] = $file->getPathname();
                    }
                }
            }
        }
        
        return $files;
    }

    private function findLineNumber(array $lines, string $needle): int
    {
        foreach ($lines as $index => $line) {
            if (strpos($line, $needle) !== false) {
                return $index + 1;
            }
        }
        return 1;
    }

    private function mapSeverity(string $severity): string
    {
        $mapping = [
            'low' => 'low',
            'moderate' => 'medium',
            'medium' => 'medium',
            'high' => 'high',
            'critical' => 'critical'
        ];
        
        return $mapping[strtolower($severity)] ?? 'medium';
    }

    private function addVulnerability(array $vulnerability): void
    {
        // Only add if severity meets threshold
        $vulnSeverity = $this->severityLevels[$vulnerability['severity']] ?? 0;
        if ($vulnSeverity < $this->minSeverity) {
            return;
        }
        
        $vulnerability['id'] = Str::uuid()->toString();
        $vulnerability['discovered_at'] = now()->toISOString();
        $vulnerability['scan_type'] = $this->option('type');
        
        $this->vulnerabilities[] = $vulnerability;
    }

    private function displayResults(): void
    {
        $this->newLine();
        $this->info('ðŸ“Š SCAN RESULTS SUMMARY');
        $this->info('========================');
        
        $severityCounts = [
            'critical' => 0,
            'high' => 0,
            'medium' => 0,
            'low' => 0
        ];
        
        foreach ($this->vulnerabilities as $vuln) {
            $severityCounts[$vuln['severity']]++;
        }
        
        $this->table(
            ['Severity', 'Count'],
            [
                ['ðŸ”´ Critical', $severityCounts['critical']],
                ['ðŸŸ  High', $severityCounts['high']],
                ['ðŸŸ¡ Medium', $severityCounts['medium']],
                ['ðŸŸ¢ Low', $severityCounts['low']],
                ['ðŸ“Š Total', count($this->vulnerabilities)]
            ]
        );
        
        if (!empty($this->vulnerabilities)) {
            $this->newLine();
            $this->warn('âš ï¸  VULNERABILITIES FOUND:');
            $this->warn('==========================');
            
            foreach ($this->vulnerabilities as $index => $vuln) {
                $severityIcon = match($vuln['severity']) {
                    'critical' => 'ðŸ”´',
                    'high' => 'ðŸŸ ',
                    'medium' => 'ðŸŸ¡',
                    'low' => 'ðŸŸ¢',
                    default => 'âšª'
                };
                
                $this->line("{$severityIcon} [{$vuln['severity']}] {$vuln['title']}");
                $this->line("   ðŸ“ File: {$vuln['file']}:{$vuln['line']}");
                $this->line("   ðŸ“ {$vuln['description']}");
                $this->line("   ðŸ’¡ {$vuln['recommendation']}");
                $this->line('');
            }
        }
    }

    private function saveResults(): void
    {
        if (!$this->option('save-results')) {
            return;
        }
        
        try {
            DB::table('security_scan_results')->insert([
                'id' => Str::uuid()->toString(),
                'scan_type' => $this->option('type'),
                'vulnerabilities' => json_encode($this->vulnerabilities),
                'scan_results' => json_encode($this->scanResults),
                'vulnerability_count' => count($this->vulnerabilities),
                'severity_counts' => json_encode($this->getSeverityCounts()),
                'created_at' => now(),
                'updated_at' => now()
            ]);
            
            $this->info('ðŸ’¾ Scan results saved to database');
            
        } catch (\Exception $e) {
            $this->error('âŒ Failed to save results: ' . $e->getMessage());
        }
    }

    private function getSeverityCounts(): array
    {
        $counts = ['critical' => 0, 'high' => 0, 'medium' => 0, 'low' => 0];
        foreach ($this->vulnerabilities as $vuln) {
            $counts[$vuln['severity']]++;
        }
        return $counts;
    }

    private function sendNotifications(): void
    {
        if (!$this->option('notify')) {
            return;
        }
        
        $criticalVulns = array_filter($this->vulnerabilities, fn($v) => $v['severity'] === 'critical');
        
        if (!empty($criticalVulns)) {
            // Send critical notifications
            Log::channel('security')->alert('Critical security vulnerabilities found', [
                'scan_type' => $this->option('type'),
                'vulnerabilities' => $criticalVulns,
                'count' => count($criticalVulns)
            ]);
            
            $this->info('ðŸ”” Critical vulnerability notifications sent');
        }
    }
}